diff --git forkSrcPrefix/client/go/outline/config/module.go forkDstPrefix/client/go/outline/config/module.go
index c3efc100d5287118b671495fa971d0b21216294b..314d6210a63cc5d6569fa5d00976160e589a711c 100644
--- forkSrcPrefix/client/go/outline/config/module.go
+++ forkDstPrefix/client/go/outline/config/module.go
@@ -96,8 +96,8 @@ func NewDefaultTransportProvider(tcpDialer transport.StreamDialer, udpDialer tra
 	})
 
 	transports := NewTypeParser(func(ctx context.Context, input ConfigNode) (*TransportPair, error) {
-		// If parser directive is missing, parse as Shadowsocks for backwards-compatibility.
-		return parseShadowsocksTransport(ctx, input, streamEndpoints.Parse, packetEndpoints.Parse)
+		// If parser directive is missing, parse as Socks5 for backwards-compatibility.
+		return parseSocks5Transport(ctx, input, streamEndpoints.Parse, packetEndpoints.Parse)
 	})
 
 	// First-Supported support.
@@ -117,6 +117,11 @@ func NewDefaultTransportProvider(tcpDialer transport.StreamDialer, udpDialer tra
 		return parseFirstSupported(ctx, input, packetListeners.Parse)
 	})
 
+	// socks5 support (currently unused since we use fallback to socks5 in parseSocks5Transport)
+	streamDialers.RegisterSubParser("socks5", func(ctx context.Context, input map[string]any) (*Dialer[transport.StreamConn], error) {
+		return parseSocks5StreamDialer(ctx, input, streamEndpoints.Parse)
+	})
+
 	// Shadowsocks support.
 	streamDialers.RegisterSubParser("shadowsocks", func(ctx context.Context, input map[string]any) (*Dialer[transport.StreamConn], error) {
 		return parseShadowsocksStreamDialer(ctx, input, streamEndpoints.Parse)
diff --git forkSrcPrefix/client/go/outline/config/config_socks5.go forkDstPrefix/client/go/outline/config/config_socks5.go
new file mode 100644
index 0000000000000000000000000000000000000000..54016aaac44b49836396af1928cc4eb57c3c60f0
--- /dev/null
+++ forkDstPrefix/client/go/outline/config/config_socks5.go
@@ -0,0 +1,98 @@
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package config
+
+import (
+	"context"
+	"fmt"
+	"net"
+
+	"github.com/Jigsaw-Code/outline-sdk/transport"
+	"github.com/Jigsaw-Code/outline-sdk/transport/socks5"
+)
+
+// Socks5Config is the format for the SOCKS5 config.
+type Socks5Config struct {
+	Endpoint ConfigNode
+	User     string
+	Password string
+}
+
+func parseSocks5StreamDialer(ctx context.Context, config ConfigNode, parseSE ParseFunc[*Endpoint[transport.StreamConn]]) (*Dialer[transport.StreamConn], error) {
+	params, err := parseSocks5Config(config)
+	if err != nil {
+		return nil, err
+	}
+	se, err := parseSE(ctx, params.Endpoint)
+	if err != nil {
+		return nil, fmt.Errorf("failed to create StreamEndpoint: %w", err)
+	}
+	sd, err := socks5.NewClient(transport.FuncStreamEndpoint(se.Connect))
+	if err != nil {
+		return nil, fmt.Errorf("failed to create StreamDialer: %w", err)
+	}
+	return &Dialer[transport.StreamConn]{ConnectionProviderInfo{ConnTypeTunneled, se.FirstHop}, sd.DialStream}, nil
+}
+
+func parseSocks5Transport(ctx context.Context, config ConfigNode, parseSE ParseFunc[*Endpoint[transport.StreamConn]], parsePE ParseFunc[*Endpoint[net.Conn]]) (*TransportPair, error) {
+	params, err := parseSocks5Config(config)
+	if err != nil {
+		return nil, err
+	}
+
+	se, err := parseSE(ctx, params.Endpoint)
+	if err != nil {
+		return nil, fmt.Errorf("failed to create StreamEndpoint: %w", err)
+	}
+	sd, err := socks5.NewClient(transport.FuncStreamEndpoint(se.Connect))
+	if err != nil {
+		return nil, fmt.Errorf("failed to create StreamDialer: %w", err)
+	}
+
+	pe, err := parsePE(ctx, params.Endpoint)
+	if err != nil {
+		return nil, fmt.Errorf("failed to create PacketEndpoint: %w", err)
+	}
+
+	sd.EnablePacket(&transport.UDPDialer{})
+
+	return &TransportPair{
+		&Dialer[transport.StreamConn]{ConnectionProviderInfo{ConnTypeTunneled, se.FirstHop}, sd.DialStream},
+		&PacketListener{ConnectionProviderInfo{ConnTypeTunneled, pe.FirstHop}, sd},
+	}, nil
+}
+
+func parseSocks5Config(node ConfigNode) (*Socks5Config, error) {
+	switch typed := node.(type) {
+	case map[string]any:
+		if _, ok := typed["endpoint"]; ok {
+			config := Socks5Config{}
+			if err := mapToAny(typed, &config); err != nil {
+				return nil, err
+			}
+			return &config, nil
+		} else {
+			return nil, fmt.Errorf("socks5 config missing endpoint")
+		}
+	default:
+		return nil, fmt.Errorf("invalid socks5 config type %T", typed)
+	}
+}
diff --git forkSrcPrefix/go.mod forkDstPrefix/go.mod
index c8d64de07fa112e4e1f07cd8ad84cc0776034e5f..bb8f93adae3955b41824014c3310327a1d7c6684 100644
--- forkSrcPrefix/go.mod
+++ forkDstPrefix/go.mod
@@ -1,8 +1,13 @@
 module github.com/Jigsaw-Code/outline-apps
 
-go 1.22.0
+go 1.24.0
+
+replace github.com/xtls/libxray => ../libXray
+replace github.com/xtls/xray-core => ../Xray-core
 
 require (
+	github.com/xtls/libxray v0.0.0-00010101000000-000000000000
+	github.com/xtls/xray-core v0.0.0-00010101000000-000000000000
 	github.com/Jigsaw-Code/outline-sdk v0.0.18
 	github.com/Jigsaw-Code/outline-sdk/x v0.0.0-20250131142109-b32720fa2c3e
 	github.com/Wifx/gonetworkmanager/v2 v2.1.0
